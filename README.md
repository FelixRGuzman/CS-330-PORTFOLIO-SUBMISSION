# CS-330-PORTFOLIO-SUBMISSION

# How do I approach designing software?
When designing software I always look at the big picture and then separate it into small goals. I tackle those goals one by one, then build the solution once I finish solving the smaller puzzles. For this chess project I planned the scene, built the first piece, then added different elements. Once those small puzzles were solved I implemented the big solution by picking out potential reusable functions (ones that make the pieces) and other overall functions that would help me iterate and develop the rest of my scene. The main design decisions that came into play were modularization and reusability.

This was shown not only in the reusable piece functions I mentioned, such as DrawRook, DrawKing, etc., but also with my NotationToWorld helper function, which made the scene manageable and clean. This project was built upon a process that focused on small prototypes, then putting everything together in the end with refining in code, structure, and design. This is something that will definitely play a part in future work or projects, as it helps with visualization of the solution.

# How do I approach developing programs?
When developing larger applications I always make sure to prototype quickly, then use what I learn from those prototypes to put them together with proper coding practices and refinement at the end. One of these practices was commenting on my code and making many small helper functions and variables, such as the NotationToWorld I previously mentioned, or my gSpeedFactor local variable that was used to make movement smoother throughout the project.

Consistent naming and other small aspects also took part. Iteration played a role in everything: camera movement, textures, and overall part building. It all worked together. This strategy helped me focus on learning via the milestones while still thinking about the big picture. Refinement will always be needed, but this approach helps keep it minimal.

# How can computer science help me reach my goals?
As a computer scientist I use the tools at my disposal to solve problems by breaking them down into smaller parts and eventually coming up with the ultimate solution. As I mentioned throughout this README, utilizing prototypes, imagining the big picture, and other aspects helped me make real-world applications that function and solve problems.
This is how I was able to finally tackle OpenGL after never being able to effectively do so when I was younger. These skills will come into play in an educational or hobby sense when I decide to go back to game development, or whenever I decide to make an animation from scratch. I’m sure the skills will transfer.

Professionally, the ability to put this all together is essential and played a huge part in this project. After all, we often have to work on other people’s projects. We usually don’t do everything from scratch, so understanding what others have built and building upon it is an essential aspect we tackled heavily in this course.
